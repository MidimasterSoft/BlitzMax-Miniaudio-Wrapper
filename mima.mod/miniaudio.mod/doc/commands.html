<html><head><title>MiniAudio Wrapper reference</title>
<link rel=stylesheet Type=text/css href='../../../../doc/bmxstyle.css'>
</head><body>
<table width=100% cellspacing=0><tr align=center><td class=small>&nbsp;</td>
<td class=small width=1%><b>mima.miniaudio:</b></td>
<td class=small width=1%><a href=#functions class=small>Functions</a></td>
<td class=small width=1%><a href=#types class=small>Types</a></td>
<td class=small width=1%><a href=#modinfo class=small>Modinfo</a></td>
<td class=small width=1%><a href='../../../../mod/mima.mod/miniaudio.mod/miniaudio.bmx' class=small>Source</a></td>
<td class=small>&nbsp;</td></tr></table>
<h1>MiniAudio Wrapper</h1>
Beta Vesion of a wrapper for miniaudio for blitzmax.

<h2
 id=functionsdet>Example
</h2>
<table class=doc width=100% cellspacing=3 id=ExampleForCallBack>
<tr><td class=doctop colspan=2>3 Examples For Playback and Capture via CallBack()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Example For A Callback.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>How to Playback and Capture Samples
<br> <b>Frames</b>: number of Samples when Mono. Number of Samples when Stereo is 2*Frames!!
<br> <b>PlayBuffer</b>: Here you put the samples for Playback
<br> <b>RecordingBuffer</b>: Here you find the samples from capture input.</td></tr>
<tr><td class=docleft width=1%><a href=ExampleForCallBack.bmx class=small>Example</a></td><td class=docright><pre>
'Example I: only playback

Import mima.miniaudio

' Setup of the device:
Global MiniAudio:TMiniAudio=New TMiniAudio
MiniAudio.GetDevice( MiniAudio.PLAYBACK, Miniaudio.FORMAT_S16, 1, 48000, MyCallBack_I)

' now start it:
MiniAudio.StartDevice()
Repeat
	Flip 1
Until AppTerminate()
Miniaudio.KillDevice()
End 

Function MyCallBack_I(void:Byte Ptr, PlayBuffer:Short Ptr, RecordingBuffer:Short Ptr, Frames%)
	For Local i:Int=0 To Frames-1
		PlayBuffer[i*2] = Rand(-32000,+32000)
	Next 
End Function 

__________________________________________________________________________________
</pre></td></tr><tr><td class=docleft width=1%><a href=ExampleForCallBack.bmx class=small>Example</a></td><td class=docright><pre>
'Example II: only capture:

Import mima.miniaudio

' Setup of the device:
Global MiniAudio:TMiniAudio=New TMiniAudio
MiniAudio.GetDevice( MiniAudio.CAPTURE, Miniaudio.FORMAT_S16, 1, 48000, MyCallBack_II)

Global Source:TAudioSample=CreateAudioSample( HERTZ*60*10,  HERTZ, SF_MONO16LE) '10seconds
Global SoundBank:TBank=CreateStaticBank(Source.Samples, Source.Length)
Global WritePointer:Int

' now start it:
MiniAudio.StartDevice()
Repeat
	Flip 1
Until AppTerminate()
Miniaudio.KillDevice()
End 


Function MyCallBack_II(void:Byte Ptr, PlayBuffer:Short Ptr, RecordingBuffer:Short Ptr, Frames%)
	For Local i:Int=0 To Frames-1
		SoundBank.PokeShort(WritePointer+i*2 , RecordingBuffer[i*2])
	Next 
	WritePointer=WritePointer + Frames*2
End Function 


____________________________________________________________________________________
</pre></td></tr><tr><td class=docleft width=1%><a href=ExampleForCallBack.bmx class=small>Example</a></td><td class=docright><pre>

'Example III: Duplex:

Import mima.miniaudio

' Setup of the device:
Global MiniAudio:TMiniAudio=New TMiniAudio
MiniAudio.GetDevice( MiniAudio.DUPLEX, Miniaudio.FORMAT_S16, 1, 48000, MyCallBack_III)

' now start it:
MiniAudio.StartDevice()
Repeat
	Flip 1
Until AppTerminate()
Miniaudio.KillDevice()
End 


Function MyCallBack(void:Byte Ptr, PlayBuffer:Short Ptr, RecordingBuffer:Short Ptr, Frames%)
	For Local i:Int=0 To Frames-1
		PlayBuffer[i*2] = RecordingBuffer[i*2]
	Next 
End Function</pre></td></tr>
</table>
<br>
<h2
 id=typesdet>Methods
</h2>
<table class=doc width=100% cellspacing=3 id=TMiniAudio>
<tr><td class=doctop colspan=2>Type TMiniAudio</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>MiniAudio-Wrapper.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Use MiniAudio as a Callback Audio device.
returns: A TMiniAudio object.</td></tr>
<tr><td class=docleft width=1%><a href=TMiniAudio.bmx class=small>Example</a></td><td class=docright><pre>' example: creating_miniaudio.bmx

Global MiniAudio:TMiniAudio=New TMiniAudio</pre></td></tr>
</table>
<table class=doc width=100% align=center><tr ><th class=doctop colspan=2 align=left><a name=TMiniAudio_methods></a>Methods Summary</th></tr>
<tr><td class=docleft width=1%><a href=#CaptureDevices>CaptureDevices</a></td><td class=docright>
Capture Devices.
</td></tr>
<tr><td class=docleft width=1%><a href=#CloseWavFile>CloseWavFile</a></td><td class=docright>
Close WAV File.
</td></tr>
<tr><td class=docleft width=1%><a href=#ConvertAudioSample>ConvertAudioSample</a></td><td class=docright>
ConvertAudioSample.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetDevice>GetDevice</a></td><td class=docright>
Get Device.
</td></tr>
<tr><td class=docleft width=1%><a href=#GetDevice_II>GetDevice_II</a></td><td class=docright>
Same as <b>GetDevice</b>, but with independent parameters for Capture and Playback:
</td></tr>
<tr><td class=docleft width=1%><a href=#KillDevice>KillDevice</a></td><td class=docright>
Kill Device.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadAudioSample>LoadAudioSample</a></td><td class=docright>
Load MP3 as TAudioSample.
</td></tr>
<tr><td class=docleft width=1%><a href=#LoadSound>LoadSound</a></td><td class=docright>
Load MP3 as TSound.
</td></tr>
<tr><td class=docleft width=1%><a href=#OpenWavFile>OpenWavFile</a></td><td class=docright>
Open WAV File for Writing.
</td></tr>
<tr><td class=docleft width=1%><a href=#PlaybackDevices>PlaybackDevices</a></td><td class=docright>
Playback Devices.
</td></tr>
<tr><td class=docleft width=1%><a href=#SaveTAudioSample>SaveTAudioSample</a></td><td class=docright>
Save TAudioSample as WAV.
</td></tr>
<tr><td class=docleft width=1%><a href=#SaveWavFile>SaveWavFile</a></td><td class=docright>
Save WAV File.
</td></tr>
<tr><td class=docleft width=1%><a href=#SelectDevices>SelectDevices</a></td><td class=docright>
Select Devices.
</td></tr>
<tr><td class=docleft width=1%><a href=#StartDevice>StartDevice</a></td><td class=docright>
Start Device.
</td></tr>
<tr><td class=docleft width=1%><a href=#StopDevice>StopDevice</a></td><td class=docright>
Stop Device.
</td></tr>
<tr><td class=docleft width=1%><a href=#WriteWavFile>WriteWavFile</a></td><td class=docright>
Write data to WAV File.
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CaptureDevices>
<tr><td class=doctop colspan=2>Method CaptureDevices:String[]()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>a String array.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Capture Devices.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Lists all avaiable hardware Capture-Devices.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=CloseWavFile>
<tr><td class=doctop colspan=2>Method CloseWavFile(Handle:MMStreamID)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Close WAV File.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>closes wav file after saving the content.
<br><br>
<br><br> <b>Handle</b> is the handle to the file returned by OpenWavFile()
<br><br>
Use together with OpenWavFile() and  WriteWavFile()</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=ConvertAudioSample>
<tr><td class=doctop colspan=2>Method ConvertAudioSample:TBank(Source:TAudioSample, Format:Int, Channels:Int, Hertz:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>a TBank object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>ConvertAudioSample.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Converts a TAudioSample into a Bank with new format, samplerate and channels.
<br><br> <b>Format</b> is the Target-format and should be one of:
<p>
<table><tr><td> <b>Format</b></td><td><b>Value</b></td><td><b>Description</b>
</td></tr><tr><td>FORMAT_U8</td><td>1</td><td>Unsigned 8 bit
</td></tr><tr><td>FORMAT_S16</td><td>2</td><td>Signed 16 bit little endian
</td></tr><tr><td>FORMAT_S24</td><td>3</td><td>Signed 24 bit little endian
</td></tr><tr><td>FORMAT_S32</td><td>4</td><td>Signed 32 bit little endian
</td></tr><tr><td>FORMAT_F32</td><td>5</td><td>Signed 32 bit Float -1 to +1</table>
<p>
<br><br> <b>Channels</b> is the target number of Channels 1 = MONO    2 = STEREO.
<br><br> <b>Hertz</b> is the target frequency in samples per second (Hz).</td></tr>
<tr><td class=docleft width=1%><a href=ConvertAudioSample.bmx class=small>Example</a></td><td class=docright><pre>SuperStrict
Import mima.miniaudio

Graphics 800,600

' Setup of the device:
Global MiniAudio:TMiniAudio=New TMiniAudio

Local Source:TAudioSample=LoadAudioSample("TestAbc.ogg")

Global ResultBank:TBank
ResultBank= MiniAudio.ConvertAudioSample(Source, Miniaudio.FORMAT_F32, 1, 12000)

'show 500 samples in old and new format:
For Local i%=1000 To 1500
	Print  i + ".Sample  Source:" +  SoundBank.PeekShort(i*2) + "-->" + Resultbank.PeekFloat(i*4)
Next 
End</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetDevice>
<tr><td class=doctop colspan=2>Method GetDevice:Int(DeviceType:Int, Format:Int, Channels:Int, SampleRate:Int, UserCallBackPointer: Byte Ptr)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>TRUE if successful.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Get Device.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Define Device Configuration
<p>
<br> <b>DeviceType</b> is one of:
<table><tr><td> <b>Device</b> Type</td><td><b>Value</b></td><td><b>Description</b>
</td></tr><tr><td>PLAYBACK</td><td>1</td><td>Use the device for Playing
</td></tr><tr><td>CAPTURE</td><td>2</td><td>Use the device for Recording
</td></tr><tr><td>DUPLEX</td><td>3</td><td>Use the device for simultanious Capture and Playing
</td></tr><tr><td>LOOPBACK</td><td>4</td><td>Record what is "on the speakers"</table>
<p>
<br><br> <b>Channels</b> is the number of Channels 1 = MONO    2 = STEREO.
<br><br> <b>SampleRate</b> is the frequency in samples per second (Hz) the audio sample will be played.
<br><br> <b>UserCallBackPointer</b> is the name of your Callback-function
<br><br> <b>Format</b> should be one of:
<p>
<table><tr><td> <b>Format</b></td><td><b>Value</b></td><td><b>Description</b>
</td></tr><tr><td>FORMAT_U8</td><td>1</td><td>Unsigned 8 bit
</td></tr><tr><td>FORMAT_S16</td><td>2</td><td>Signed 16 bit little endian
</td></tr><tr><td>FORMAT_S24</td><td>3</td><td>Signed 24 bit little endian
</td></tr><tr><td>FORMAT_S32</td><td>4</td><td>Signed 32 bit little endian
</td></tr><tr><td>FORMAT_F32</td><td>5</td><td>Signed 32 bit Float -1 to +1</table>
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=GetDevice_II>
<tr><td class=doctop colspan=2>Method GetDevice_II:Int(DeviceType:Int, PlayFormat:Int, PlayChannels:Int,  CaptFormat:Int, CaptChannels:Int,SampleRate:Int, UserCallBackPointer: Byte Ptr)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>TRUE if successful.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Same as <b>GetDevice</b>, but with independent parameters for Capture and Playback:</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Define two different Device Configurations for Duplex
<p>
<br> <b>DeviceType</b> is :
<table><tr><td> <b>Device</b> Type</td><td><b>Value</b></td><td><b>Description</b>
</td></tr><tr><td>DUPLEX</td><td>3</td><td>Use the device for simultanious Capture and Playback</table>
<p>
<br><br> <b>PlayChannels</b> is the number of Channels when playback 1 = MONO    2 = STEREO.
<br><br> <b>CaptChannels</b> is the number of Channels when capture  1 = MONO    2 = STEREO.
<br><br> <b>SampleRate</b> is a common frequency in samples per second (Hz) for capture and playback.
<br><br> <b>PlayFormat</b> and <b>CaptFormat</b> can be any one of:
<table><tr><td> <b>Format</b></td><td><b>Value</b></td><td><b>Description</b>
</td></tr><tr><td>FORMAT_U8</td><td>1</td><td>Unsigned 8 bit
</td></tr><tr><td>FORMAT_S16</td><td>2</td><td>Signed 16 bit little endian
</td></tr><tr><td>FORMAT_S24</td><td>3</td><td>Signed 24 bit little endian
</td></tr><tr><td>FORMAT_S32</td><td>4</td><td>Signed 32 bit little endian
</td></tr><tr><td>FORMAT_F32</td><td>5</td><td>Signed 32 bit Float -1 to +1</table>
</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=KillDevice>
<tr><td class=doctop colspan=2>Method KillDevice()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Kill Device.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Deletes the Device.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=LoadAudioSample>
<tr><td class=doctop colspan=2>Method LoadAudioSample:TAudioSample(File:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>a TAudioSample object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load MP3 as TAudioSample.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Loads an audio MP3, FLAC or WAV file.  24bit-, 32bit- and 32bit-float-files will return 16bit TAudioSample. No need for Defining or Starting the device.</td></tr>
<tr><td class=docleft width=1%><a href=LoadAudioSample.bmx class=small>Example</a></td><td class=docright><pre>' example: loadAudioSample.bmx

Global MiniAudio:TMiniAudio=New TMiniAudio

Local MySample:TAudioSample = MiniAudio.LoadAudioSample("TestABC.flac")

Local MySound:TSound=LoadSound(MySample)
PlaySound MySound</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=LoadSound>
<tr><td class=doctop colspan=2>Method LoadSound:TSound(File:String)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>a TSound object.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Load MP3 as TSound.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Loads an audio MP3, FlAC or WAV file. No need for Defining or Starting the device.
Also 24bit-, 32bit- and 32bit-float files are processed.</td></tr>
<tr><td class=docleft width=1%><a href=LoadSound.bmx class=small>Example</a></td><td class=docright><pre>' example: loadsound.bmx

Global MiniAudio:TMiniAudio = New TMiniAudio

Local MySound:TSound = MiniAudio.LoadSound("TestABC.mp3")
PlaySound MySound</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=OpenWavFile>
<tr><td class=doctop colspan=2>Method OpenWavFile:MMStreamID(FileName:String, Format:Int, Channels:Int, Hertz:Int)</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>The handle to the file as MMStreamID.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Open WAV File for Writing.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Opens a file for saving the content of a  TBank as a WAV file. Use it to save data in intervalls, when want to change
format or when data will be  longer than 2GB
<br><br> No need for Defining or Starting the device
<br><br> <b>FileName</b> is the path +name of the audio file
<br><br> <b>Channels</b> is the number of Channels 1 - 32.
<br><br> <b>Hertz</b> is the frequency in samples per second (Hz) the file will have.
<br><br> <b>Format</b> should be one of:
<table><tr><td> <b>Format</b></td><td><b>Value</b></td><td><b>Description</b>
</td></tr><tr><td>FORMAT_U8</td><td>1</td><td>Unsigned 8 bit
</td></tr><tr><td>FORMAT_S16</td><td>2</td><td>Signed 16 bit little endian
</td></tr><tr><td>FORMAT_S24</td><td>3</td><td>Signed 24 bit little endian
</td></tr><tr><td>FORMAT_S32</td><td>4</td><td>Signed 32 bit little endian
</td></tr><tr><td>FORMAT_F32</td><td>5</td><td>Signed 32 bit Float -1 to +1</table>
<p>
Use together with WriteWavFile() and CloseWavFile()</td></tr>
<tr><td class=docleft width=1%><a href=OpenWavFile.bmx class=small>Example</a></td><td class=docright><pre>' open_wav_file.bmx
SuperStrict
Import mima.miniaudio
' Setup of the device:
Global MiniAudio:TMiniAudio=New TMiniAudio

Global Stream:MMStreamID= MiniAudio.OpenWavFile("test.wav" , Miniaudio.FORMAT_F32 , 3 , 44100 )
Print "StreamID=" + Stream.Id
Global mode%, time%, Part%
While Part<10
	If time < MilliSecs()
		time = MilliSecs() + 500
		Part=Part+1
		PartRecord
		Print "recording part no. " + Part
	EndIf 
	Delay 100
Wend 
MiniAudio.CloseWavFile(Stream )
End 

Function PartRecord()
	mode = (mode+1) Mod 3 ' only for demonstration of 3 channels

	Local Bank:TBank=CreateBank(5000*4*3+12)    ' 44.1kHz * 32bit * 3tracks * 2seconds
	Global FrameLength% = 4*3  ' 32bit*3tracks
	For Local I%=0 To 4999
		Local pos:Int=i*FrameLength
		Local v#=Sin(i)/2
		Bank.PokeFloat(Pos+mode*4, v)
	Next 
	MiniAudio.WriteWavFile(Stream, Bank, 5000)
End Function</pre></td></tr>




</table>
<table class=doc width=100% cellspacing=3 id=PlaybackDevices>
<tr><td class=doctop colspan=2>Method PlaybackDevices:String[]()</td></tr>
<tr><td class=docleft width=1%>Returns</td><td class=docright>a String array.</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Playback Devices.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Lists all avaiable hardware Playback-Devices.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SaveTAudioSample>
<tr><td class=doctop colspan=2>Method SaveTAudioSample(FileName:String, Sample:TAudioSample)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Save TAudioSample as WAV.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Saves a TAudioSample as a WAV file.
<br><br> <b>FileName</b> is the path +name of the audio file
<br><br> <b>Sample</b> is the  TAudioSample
<br><br> <b>Format</b> of Sample should be one of the BlitzMax audio-formats: SF_MONO8, SF_MONO16LE, SF_STEREO8, SF_STEREO16LE
<br><br> No need for Defining or Starting the device
<br><br>
Use <b>OpenWavFile</b>() if you need to convert format or data is longer than 2GB.</td></tr>
<tr><td class=docleft width=1%><a href=SaveTAudioSample.bmx class=small>Example</a></td><td class=docright><pre>' save_taudiosample.bmx
SuperStrict
Import mima.miniaudio
' Setup of the device:
Global MiniAudio:TMiniAudio=New TMiniAudio

Global Sample:TAudioSample=LoadAudioSample("TestABC.ogg")

MiniAudio.SaveTAudioSample("TestABC.wav", Sample)

End</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SaveWavFile>
<tr><td class=doctop colspan=2>Method SaveWavFile(FileName:String, Bank:TBank, Format:Int, Channels:Int, Hertz:Int, Frames:Int)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Save WAV File.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Saves the content of a  TBank as a WAV file. The content of the TBank must have the same format as the WAV file. No need for Defining or Starting the device
<br><br> <b>FileName</b> is the path +name of the audio file
<br><br> <b>Bank</b> is a TBank which contains the samples
<br><br> <b>Channels</b> is the number of Channels 1 - 32.
<br><br> <b>Hertz</b> is the frequency in samples per second (Hz) the Samples are captured.
<br><br> <b>Format</b> should be one of:
<table><tr><td> <b>Format</b></td><td><b>Value</b></td><td><b>Description</b>
</td></tr><tr><td>FORMAT_U8</td><td>1</td><td>Unsigned 8 bit
</td></tr><tr><td>FORMAT_S16</td><td>2</td><td>Signed 16 bit little endian
</td></tr><tr><td>FORMAT_S24</td><td>3</td><td>Signed 24 bit little endian
</td></tr><tr><td>FORMAT_S32</td><td>4</td><td>Signed 32 bit little endian
</td></tr><tr><td>FORMAT_F32</td><td>5</td><td>Signed 32 bit Float -1 to +1</table>
<p>
<b>Frames</b> is is independent of Format and Channels and needs to be calculated by multiplication (Hertz*Seconds)
or can also be calculated by TotalBytes/Channels/Format. So 32bit format and 5 channels are 4*5=20Bytes, but still only one frame!!!
Use <b>OpenWavFile</b>() if you need to convert format or data is longer than 2GB.</td></tr>
<tr><td class=docleft width=1%><a href=SaveWavFile.bmx class=small>Example</a></td><td class=docright><pre>' save_wav_file.bmx
SuperStrict
Import mima.miniaudio
' Setup of the device:
Global MiniAudio:TMiniAudio=New TMiniAudio

Global Bank:TBank=CreateBank(44100*4*3*2)    ' 44.1kHz * 32bit * 3tracks * 2seconds
Global FrameLength% = 4*3  ' 32bit*3tracks

For Local I%=0 To (44100*2-FrameLength)
	Local pos:Int=i*FrameLength
	
	'track 1 (sinus):
	Local v#=Sin(i)/2
	Bank.PokeFloat(Pos+0, v)
	
	' track 2 (silence): 
	Bank.PokeFloat(Pos+4, 0)
	
	'track 3 (noise): 
	v=Rnd()-0.5
	Bank.PokeFloat(Pos+8, v) 
Next 

MiniAudio.SaveWavFile("capture.wav" , Bank , Miniaudio.FORMAT_F32 , 3 , 44100 , 44100*2)
End</pre></td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=SelectDevices>
<tr><td class=doctop colspan=2>Method SelectDevices(ID_Playback:Int=0, ID_Capture:Int=0)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Select Devices.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Select one from the avaiable hardware Devices. For ID_.. use their position in the string arrays  PlaybackDevices[] and CaptureDevices[].
The selection must be done before calling MiniAudio.GetDevice().</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=StartDevice>
<tr><td class=doctop colspan=2>Method StartDevice()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Start Device.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Runs the Device or Continue Device.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=StopDevice>
<tr><td class=doctop colspan=2>Method StopDevice()</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Stop Device.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>Pauses the Device.</td></tr>
</table>
<table class=doc width=100% cellspacing=3 id=WriteWavFile>
<tr><td class=doctop colspan=2>Method WriteWavFile(Handle:MMStreamID, Bank:TBank, Frames:Int, Format:Int=0, Channels:Int=0, Hertz:Int=0)</td></tr>
<tr><td class=docleft width=1%>Description</td><td class=docright>Write data to WAV File.</td></tr>
<tr><td class=docleft width=1%>Information</td><td class=docright>writes to an opened wav file for saving the content of a  TBank. Use it to save data in intervalls, when want to change
format or when data will be  longer than 2GB
<br><br> <b>Handle</b> is the handle to the file returned by OpenWavFile()
<br><br> <b>Bank</b> is a TBank which contains the samples
<br><br> <b>Frames</b> is is independent of Format and Channels and needs to be calculated by multiplication (Hertz*Seconds)
or can also be calculated by TotalBytes/Channels/Format. So 32bit format and 5 channels are 4*5=20Bytes, but still only one frame!!!
<br><br>
<table><tr><td> Only if you need to convert datas between Samples and file:
</td></tr><tr><td><b>Channels</b> is the number of source- channels 1 - 32.
</td></tr><tr><td><b>Hertz</b> is the frequency in samples per second (Hz) the source datas have.
</td></tr><tr><td><b>Format</b> is the source datas have.</table>
<p>
<b>Format</b> should be one of:
<table><tr><td> <b>Format</b></td><td><b>Value</b></td><td><b>Description</b>
</td></tr><tr><td>FORMAT_U8</td><td>1</td><td>Unsigned 8 bit
</td></tr><tr><td>FORMAT_S16</td><td>2</td><td>Signed 16 bit little endian
</td></tr><tr><td>FORMAT_S24</td><td>3</td><td>Signed 24 bit little endian
</td></tr><tr><td>FORMAT_S32</td><td>4</td><td>Signed 32 bit little endian
</td></tr><tr><td>FORMAT_F32</td><td>5</td><td>Signed 32 bit Float -1 to +1</table>
<p>
Use together with <b>OpenWavFile</b>() and <b>CloseWavFile</b>()</td></tr>
</table>
<br>
<h2 id=modinfo>Module Information</h2>
<table width=100%>
<tr><th width=1%>Version</th><td>MiniAudio: 0.10.35</td></tr>
<tr><th width=1%>Version</th><td>Wrapper: 1.20</td></tr>
<tr><th width=1%>License</th><td>MIT(0)</td></tr>
<tr><th width=1%>Copyright</th><td>MINIAUDIO David Reid - mackron@gmail.com  https://miniaud.io</td></tr>
<tr><th width=1%>Copyright</th><td>WRAPPER Peter Wolkersdorfer	www.midimaster.de, thanks To COL from www.github.com/davecamp</td></tr>
<tr><th width=1%>History</th><td>1.20 Save WAV-file</td></tr>
<tr><th width=1%>History</th><td>1.19 capture and playback n-channel via hardware devices</td></tr>
<tr><th width=1%>History</th><td>1.18 Load FLAC and WAV 24bit, 32bit and 32bit-float</td></tr>
<tr><th width=1%>History</th><td>1.17 modiefied miniaudio.h because of debug problem</td></tr>
<tr><th width=1%>History</th><td>1.16 enumerate devices and select them</td></tr>
<tr><th width=1%>History</th><td>1.15 now designed as a module</td></tr>
<tr><th width=1%>History</th><td>1.14 Add format-, hertz- and channel-converting</td></tr>
<tr><th width=1%>History</th><td>1.13 Add separate Formats for Capture and Playback</td></tr>
<tr><th width=1%>History</th><td>1.12 Add LoadSound_MP3 and LoadAudioSample_MP3</td></tr>
<tr><th width=1%>History</th><td>1.11 Rebuild wrapper as module</td></tr>
<tr><th width=1%>History</th><td>1.10 Add MP3-Load</td></tr>
</body></html>
